{
    "language": "Solidity",
    "sources": {
      "contracts/Authority.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.15;\n\nimport \"./interfaces/IAuthority.sol\";\n\nimport \"./libraries/types/AccessControlled.sol\";\n\ncontract Authority is IAuthority, AccessControlled {\n  /* ========== STATE VARIABLES ========== */\n\n  address public override governor;\n\n  address public override guardian;\n\n  address public override policy;\n\n  address public override vault;\n\n  address public newGovernor;\n\n  address public newGuardian;\n\n  address public newPolicy;\n\n  address public newVault;\n\n  /* ========== Constructor ========== */\n\n  constructor(\n    address _governor,\n    address _guardian,\n    address _policy,\n    address _vault\n  )  {\n    intitalizeAuthority(IAuthority(address(this)));\n    governor = _governor;\n    emit GovernorPushed(address(0), governor, true);\n    guardian = _guardian;\n    emit GuardianPushed(address(0), guardian, true);\n    policy = _policy;\n    emit PolicyPushed(address(0), policy, true);\n    vault = _vault;\n    emit VaultPushed(address(0), vault, true);\n  }\n\n  /* ========== GOV ONLY ========== */\n\n  function pushGovernor(address _newGovernor, bool _effectiveImmediately)\n    external\n    onlyGovernor\n  {\n    if (_effectiveImmediately) governor = _newGovernor;\n    newGovernor = _newGovernor;\n    emit GovernorPushed(governor, newGovernor, _effectiveImmediately);\n  }\n\n  function pushGuardian(address _newGuardian, bool _effectiveImmediately)\n    external\n    onlyGovernor\n  {\n    if (_effectiveImmediately) guardian = _newGuardian;\n    newGuardian = _newGuardian;\n    emit GuardianPushed(guardian, newGuardian, _effectiveImmediately);\n  }\n\n  function pushPolicy(address _newPolicy, bool _effectiveImmediately)\n    external\n    onlyGovernor\n  {\n    if (_effectiveImmediately) policy = _newPolicy;\n    newPolicy = _newPolicy;\n    emit PolicyPushed(policy, newPolicy, _effectiveImmediately);\n  }\n\n  function pushVault(address _newVault, bool _effectiveImmediately)\n    external\n    onlyGovernor\n  {\n    if (_effectiveImmediately) vault = _newVault;\n    newVault = _newVault;\n    emit VaultPushed(vault, newVault, _effectiveImmediately);\n  }\n\n  /* ========== PENDING ROLE ONLY ========== */\n\n  function pullGovernor() external {\n    require(msg.sender == newGovernor, \"!newGovernor\");\n    emit GovernorPulled(governor, newGovernor);\n    governor = newGovernor;\n  }\n\n  function pullGuardian() external {\n    require(msg.sender == newGuardian, \"!newGuard\");\n    emit GuardianPulled(guardian, newGuardian);\n    guardian = newGuardian;\n  }\n\n  function pullPolicy() external {\n    require(msg.sender == newPolicy, \"!newPolicy\");\n    emit PolicyPulled(policy, newPolicy);\n    policy = newPolicy;\n  }\n\n  function pullVault() external {\n    require(msg.sender == newVault, \"!newVault\");\n    emit VaultPulled(vault, newVault);\n    vault = newVault;\n  }\n}\n"
      },
      "contracts/interfaces/IAuthority.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.8.15;\n\ninterface IAuthority {\n    /* ========== EVENTS ========== */\n\n    event GovernorPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n    event GuardianPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n    event PolicyPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n    event VaultPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n\n    event GovernorPulled(address indexed from, address indexed to);\n    event GuardianPulled(address indexed from, address indexed to);\n    event PolicyPulled(address indexed from, address indexed to);\n    event VaultPulled(address indexed from, address indexed to);\n\n    /* ========== VIEW ========== */\n\n    function governor() external view returns (address);\n\n    function guardian() external view returns (address);\n\n    function policy() external view returns (address);\n\n    function vault() external view returns (address);\n}\n"
      },
      "contracts/libraries/types/AccessControlled.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.15;\n\nimport \"../../interfaces/IAuthority.sol\";\n\nabstract contract AccessControlled {\n  /* ========== EVENTS ========== */\n\n  event AuthorityUpdated(IAuthority indexed authority);\n\n  string UNAUTHORIZED = \"UNAUTHORIZED\"; // save gas\n\n  /* ========== STATE VARIABLES ========== */\n\n  IAuthority public authority;\n\n  /* ========== Constructor ========== */\n\n  function intitalizeAuthority(IAuthority _authority) internal {\n    authority = _authority;\n  }\n\n  /* ========== MODIFIERS ========== */\n\n  modifier onlyGovernor() {\n    require(msg.sender == authority.governor(), UNAUTHORIZED);\n    _;\n  }\n\n  modifier onlyGuardian() {\n    require(msg.sender == authority.guardian(), UNAUTHORIZED);\n    _;\n  }\n\n  modifier onlyPolicy() {\n    require(msg.sender == authority.policy(), UNAUTHORIZED);\n    _;\n  }\n\n  modifier onlyVault() {\n    require(msg.sender == authority.vault(), UNAUTHORIZED);\n    _;\n  }\n\n  /* ========== GOV ONLY ========== */\n\n  function setAuthority(IAuthority _newAuthority) external onlyGovernor {\n    authority = _newAuthority;\n    emit AuthorityUpdated(_newAuthority);\n  }\n}\n"
      },
      "contracts/mocks/MockTreasury.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.8.15;\n\nimport \"../interfaces/ITreasury.sol\";\nimport \"../interfaces/ERC20/IERC20Mintable.sol\";\nimport \"../Authority.sol\";\n\ncontract Treasury is ITreasury, Authority {\n    IERC20Mintable REQ;\n\n    constructor(address _req) Authority(msg.sender, msg.sender, msg.sender, msg.sender) {\n        REQ = IERC20Mintable(_req);\n    }\n\n    function deposit(\n        uint256 _amount,\n        address _token,\n        uint256 _profit\n    ) external returns (uint256) {}\n\n    function withdraw(uint256 _amount, address _token) external {}\n\n    function assetValue(address _token, uint256 _amount) external view returns (uint256 value_) {}\n\n    function mint(address _recipient, uint256 _amount) external {\n      REQ.mint(_recipient, _amount);\n    }\n\n    function manage(address _token, uint256 _amount) external {}\n\n    function incurDebt(uint256 amount_, address token_) external {}\n\n    function repayDebtWithReserve(uint256 amount_, address token_) external {}\n\n    function excessReserves() external view returns (int256) {}\n\n    function baseSupply() external view returns (uint256) {}\n}\n"
      },
      "contracts/interfaces/ITreasury.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.8.15;\n\ninterface ITreasury {\n    function deposit(\n        uint256 _amount,\n        address _token,\n        uint256 _profit\n    ) external returns (uint256);\n\n    function withdraw(uint256 _amount, address _token) external;\n\n    function assetValue(address _token, uint256 _amount) external view returns (uint256 value_);\n\n    function mint(address _recipient, uint256 _amount) external;\n\n    function manage(address _token, uint256 _amount) external;\n\n    function incurDebt(uint256 amount_, address token_) external;\n\n    function repayDebtWithReserve(uint256 amount_, address token_) external;\n\n    function excessReserves() external view returns (int256);\n\n    function baseSupply() external view returns (uint256);\n}\n"
      },
      "contracts/interfaces/ERC20/IERC20Mintable.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\ninterface IERC20Mintable {\n\n  function mint(address account_, uint256 amount_) external;\n}\n"
      },
      "contracts/libraries/types/NoteKeeper.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./FrontEndRewarder.sol\";\n\nimport \"../../interfaces/IgREQ.sol\";\n// import \"../../interfaces/IStaking.sol\";\nimport \"../../interfaces/ITreasury.sol\";\nimport \"../../interfaces/INoteKeeper.sol\";\n\n// solhint-disable max-line-length\n\nabstract contract NoteKeeper is INoteKeeper, FrontEndRewarder {\n    // mapping(address => Note[]) public notes; // user deposit data\n    // mapping(address => mapping(uint256 => address)) private noteTransfers; // change note ownership\n\n    // IgREQ internal immutable gREQ;\n    // IStaking internal immutable staking;\n    // ITreasury internal treasury;\n\n    // constructor(\n    //     IAuthority _authority,\n    //     IERC20 _req,\n    //     IgREQ _greq,\n    //     IStaking _staking,\n    //     ITreasury _treasury\n    // ) FrontEndRewarder(_authority, _req) {\n    //     gREQ = _greq;\n    //     staking = _staking;\n    //     treasury = _treasury;\n    // }\n\n    // // if treasury address changes on authority, update it\n    // function updateTreasury() external {\n    //     require(\n    //         msg.sender == authority.governor() ||\n    //             msg.sender == authority.guardian() ||\n    //             msg.sender == authority.policy(),\n    //         \"Only authorized\"\n    //     );\n    //     treasury = ITreasury(authority.vault());\n    // }\n\n    // /* ========== ADD ========== */\n\n    // /**\n    //  * @notice             adds a new Note for a user, stores the front end & DAO rewards, and mints & stakes payout & rewards\n    //  * @param _user        the user that owns the Note\n    //  * @param _payout      the amount of REQ due to the user\n    //  * @param _expiry      the timestamp when the Note is redeemable\n    //  * @param _marketID    the ID of the market deposited into\n    //  * @return index_      the index of the Note in the user's array\n    //  */\n    // function addNote(\n    //     address _user,\n    //     uint256 _payout,\n    //     uint48 _expiry,\n    //     uint48 _marketID,\n    //     address _referral\n    // ) internal returns (uint256 index_) {\n    //     // the index of the note is the next in the user's array\n    //     index_ = notes[_user].length;\n\n    //     // the new note is pushed to the user's array\n    //     notes[_user].push(\n    //         Note({\n    //             payout: gREQ.balanceTo(_payout),\n    //             created: uint48(block.timestamp),\n    //             matured: _expiry,\n    //             redeemed: 0,\n    //             marketID: _marketID\n    //         })\n    //     );\n\n    //     // front end operators can earn rewards by referring users\n    //     uint256 rewards = _giveRewards(_payout, _referral);\n\n    //     // mint and stake payout\n    //     treasury.mint(address(this), _payout + rewards);\n\n    //     // note that only the payout gets staked (front end rewards are in REQ)\n    //     staking.stake(address(this), _payout, false, true);\n    // }\n\n    // /* ========== REDEEM ========== */\n\n    // /**\n    //  * @notice             redeem notes for user\n    //  * @param _user        the user to redeem for\n    //  * @param _indexes     the note indexes to redeem\n    //  * @param _sendgREQ    send payout as gREQ or sREQ\n    //  * @return payout_     sum of payout sent, in gREQ\n    //  */\n    // function redeem(\n    //     address _user,\n    //     uint256[] memory _indexes,\n    //     bool _sendgREQ\n    // ) public override returns (uint256 payout_) {\n    //     uint48 time = uint48(block.timestamp);\n\n    //     for (uint256 i = 0; i < _indexes.length; i++) {\n    //         (uint256 pay, bool matured) = pendingFor(_user, _indexes[i]);\n\n    //         if (matured) {\n    //             notes[_user][_indexes[i]].redeemed = time; // mark as redeemed\n    //             payout_ += pay;\n    //         }\n    //     }\n\n    //     if (_sendgREQ) {\n    //         gREQ.transfer(_user, payout_); // send payout as gREQ\n    //     } else {\n    //         staking.unwrap(_user, payout_); // unwrap and send payout as sREQ\n    //     }\n    // }\n\n    // /**\n    //  * @notice             redeem all redeemable markets for user\n    //  * @dev                if possible, query indexesFor() off-chain and input in redeem() to save gas\n    //  * @param _user        user to redeem all notes for\n    //  * @param _sendgREQ    send payout as gREQ or sREQ\n    //  * @return             sum of payout sent, in gREQ\n    //  */\n    // function redeemAll(address _user, bool _sendgREQ) external override returns (uint256) {\n    //     return redeem(_user, indexesFor(_user), _sendgREQ);\n    // }\n\n    // /* ========== TRANSFER ========== */\n\n    // /**\n    //  * @notice             approve an address to transfer a note\n    //  * @param _to          address to approve note transfer for\n    //  * @param _index       index of note to approve transfer for\n    //  */\n    // function pushNote(address _to, uint256 _index) external override {\n    //     require(notes[msg.sender][_index].created != 0, \"Depository: note not found\");\n    //     noteTransfers[msg.sender][_index] = _to;\n    // }\n\n    // /**\n    //  * @notice             transfer a note that has been approved by an address\n    //  * @param _from        the address that approved the note transfer\n    //  * @param _index       the index of the note to transfer (in the sender's array)\n    //  */\n    // function pullNote(address _from, uint256 _index) external override returns (uint256 newIndex_) {\n    //     require(noteTransfers[_from][_index] == msg.sender, \"Depository: transfer not found\");\n    //     require(notes[_from][_index].redeemed == 0, \"Depository: note redeemed\");\n\n    //     newIndex_ = notes[msg.sender].length;\n    //     notes[msg.sender].push(notes[_from][_index]);\n\n    //     delete notes[_from][_index];\n    // }\n\n    // /* ========== VIEW ========== */\n\n    // // Note info\n\n    // /**\n    //  * @notice             all pending notes for user\n    //  * @param _user        the user to query notes for\n    //  * @return             the pending notes for the user\n    //  */\n    // function indexesFor(address _user) public view override returns (uint256[] memory) {\n    //     Note[] memory info = notes[_user];\n\n    //     uint256 length;\n    //     for (uint256 i = 0; i < info.length; i++) {\n    //         if (info[i].redeemed == 0 && info[i].payout != 0) length++;\n    //     }\n\n    //     uint256[] memory indexes = new uint256[](length);\n    //     uint256 position;\n\n    //     for (uint256 i = 0; i < info.length; i++) {\n    //         if (info[i].redeemed == 0 && info[i].payout != 0) {\n    //             indexes[position] = i;\n    //             position++;\n    //         }\n    //     }\n\n    //     return indexes;\n    // }\n\n    // /**\n    //  * @notice             calculate amount available for claim for a single note\n    //  * @param _user        the user that the note belongs to\n    //  * @param _index       the index of the note in the user's array\n    //  * @return payout_     the payout due, in gREQ\n    //  * @return matured_    if the payout can be redeemed\n    //  */\n    // function pendingFor(address _user, uint256 _index) public view override returns (uint256 payout_, bool matured_) {\n    //     Note memory note = notes[_user][_index];\n\n    //     payout_ = note.payout;\n    //     matured_ = note.redeemed == 0 && note.matured <= block.timestamp && note.payout != 0;\n    // }\n}\n"
      },
      "contracts/libraries/types/FrontEndRewarder.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./AccessControlled.sol\";\nimport \"../../interfaces/ERC20/IERC20.sol\";\n\nabstract contract FrontEndRewarder is AccessControlled {\n  /* ========= STATE VARIABLES ========== */\n\n  uint256 public daoReward; // % reward for dao (3 decimals: 100 = 1%)\n  uint256 public refReward; // % reward for referrer (3 decimals: 100 = 1%)\n  mapping(address => uint256) public rewards; // front end operator rewards\n  mapping(address => bool) public whitelisted; // whitelisted status for operators\n\n  IERC20 internal immutable req; // reward token\n\n  constructor(IAuthority _authority, IERC20 _req) {\n    intitalizeAuthority(IAuthority(_authority));\n    req = _req;\n  }\n\n  /* ========= EXTERNAL FUNCTIONS ========== */\n\n  // pay reward to front end operator\n  function getReward() external {\n    uint256 reward = rewards[msg.sender];\n\n    rewards[msg.sender] = 0;\n    req.transfer(msg.sender, reward);\n  }\n\n  /* ========= INTERNAL ========== */\n\n  /**\n   * @notice add new market payout to user data\n   */\n  function _giveRewards(uint256 _payout, address _referral)\n    internal\n    returns (uint256)\n  {\n    // first we calculate rewards paid to the DAO and to the front end operator (referrer)\n    uint256 toDAO = (_payout * daoReward) / 1e4;\n    uint256 toRef = (_payout * refReward) / 1e4;\n\n    // and store them in our rewards mapping\n    if (whitelisted[_referral]) {\n      rewards[_referral] += toRef;\n      rewards[authority.guardian()] += toDAO;\n    } else {\n      // the DAO receives both rewards if referrer is not whitelisted\n      rewards[authority.guardian()] += toDAO + toRef;\n    }\n    return toDAO + toRef;\n  }\n\n  /**\n   * @notice set rewards for front end operators and DAO\n   */\n  function setRewards(uint256 _toFrontEnd, uint256 _toDAO)\n    external\n    onlyGovernor\n  {\n    refReward = _toFrontEnd;\n    daoReward = _toDAO;\n  }\n\n  /**\n   * @notice add or remove addresses from the reward whitelist\n   */\n  function whitelist(address _operator) external onlyPolicy {\n    whitelisted[_operator] = !whitelisted[_operator];\n  }\n}\n"
      },
      "contracts/interfaces/IgREQ.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.8.15;\n\nimport \"./ERC20/IERC20.sol\";\n\ninterface IgREQ is IERC20 {\n    function mint(address _to, uint256 _amount) external;\n\n    function burn(address _from, uint256 _amount) external;\n\n    function index() external view returns (uint256);\n\n    function balanceFrom(uint256 _amount) external view returns (uint256);\n\n    function balanceTo(uint256 _amount) external view returns (uint256);\n\n    function migrate(address _staking, address _sREQ) external;\n}\n"
      },
      "contracts/interfaces/INoteKeeper.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.15;\n\ninterface INoteKeeper {\n    // Info for market note\n    struct Note {\n        uint256 payout; // gREQ remaining to be paid\n        uint48 created; // time market was created\n        uint48 matured; // timestamp when market is matured\n        uint48 redeemed; // time market was redeemed\n        uint48 marketID; // market ID of deposit. uint48 to avoid adding a slot.\n    }\n\n    function redeem(\n        address _user,\n        uint256[] memory _indexes,\n        bool _sendgREQ\n    ) external returns (uint256);\n\n    function redeemAll(address _user, bool _sendgREQ) external returns (uint256);\n\n    function pushNote(address to, uint256 index) external;\n\n    function pullNote(address from, uint256 index) external returns (uint256 newIndex_);\n\n    function indexesFor(address _user) external view returns (uint256[] memory);\n\n    function pendingFor(address _user, uint256 _index) external view returns (uint256 payout_, bool matured_);\n}\n"
      },
      "contracts/interfaces/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
      },
      "contracts/pricers/WeightedPoolPricer.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\nimport \"../interfaces/IAssetPricer.sol\";\nimport \"../interfaces/ERC20/IERC20.sol\";\nimport \"../interfaces/ISwap.sol\";\nimport \"../libraries/math/FixedPoint.sol\";\nimport \"../interfaces/IStableLPToken.sol\";\n\n/**\n * Bonding calculator for stable pool\n */\ncontract WeightedPoolPricer is IAssetPricer {\n  using FixedPoint for *;\n\n  address public immutable QUOTE;\n\n  constructor(address _QUOTE) {\n    require(_QUOTE != address(0));\n    QUOTE = _QUOTE;\n  }\n\n  // calculates the liquidity value denominated in the provided token\n  // uses the 0.01% inputAmount for that calculation\n  // note that we never use the actual LP as input as the swap contains the LP address\n  // and is also used to extract the balances\n  function getTotalValue(address _lpAddress)\n    public\n    view\n    returns (uint256 _value)\n  {\n    ISwap swap = IStableLPToken(_lpAddress).swap();\n    IERC20[] memory tokens = swap.getPooledTokens();\n    uint256[] memory reserves = swap.getTokenBalances();\n    for (uint8 i = 0; i < reserves.length; i++) {\n      address tokenAddr = address(tokens[i]);\n      if (tokenAddr != QUOTE) {\n        _value +=\n          swap.calculateSwapGivenIn(tokenAddr, QUOTE, reserves[i] / 10000) *\n          10000;\n      }\n    }\n  }\n\n  function valuation(address _lpAddress, uint256 amount_)\n    external\n    view\n    override\n    returns (uint256 _value)\n  {\n    uint256 totalValue = getTotalValue(_lpAddress);\n    uint256 totalSupply = IStableLPToken(_lpAddress).totalSupply();\n\n    _value =\n      (totalValue *\n        FixedPoint.fraction(amount_, totalSupply).decode112with18()) /\n      1e18;\n  }\n\n  function markdown(address _lpAddress) external view returns (uint256) {\n    return getTotalValue(_lpAddress);\n  }\n}\n"
      },
      "contracts/interfaces/IAssetPricer.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\ninterface IAssetPricer {\n  function valuation(address _asset, uint256 _amount)\n    external\n    view\n    returns (uint256);\n}\n"
      },
      "contracts/interfaces/ISwap.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport \"./ERC20/IERC20.sol\";\n\ninterface ISwap {\n  function calculateSwapGivenIn(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn\n  ) external view returns (uint256);\n\n  function getTokenBalances() external view returns (uint256[] memory);\n\n  function getPooledTokens() external view returns (IERC20[] memory);\n}\n"
      },
      "contracts/libraries/math/FixedPoint.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"./FullMath.sol\";\n\nlibrary FixedPoint {\n  struct uq112x112 {\n    uint224 _x;\n  }\n\n  struct uq144x112 {\n    uint256 _x;\n  }\n\n  uint8 private constant RESOLUTION = 112;\n  uint256 private constant Q112 = 0x10000000000000000000000000000;\n  uint256 private constant Q224 =\n    0x100000000000000000000000000000000000000000000000000000000;\n  uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\n\n  function decode(uq112x112 memory self) internal pure returns (uint112) {\n    return uint112(self._x >> RESOLUTION);\n  }\n\n  function decode112with18(uq112x112 memory self)\n    internal\n    pure\n    returns (uint256)\n  {\n    return uint256(self._x) / 5192296858534827;\n  }\n\n  function fraction(uint256 numerator, uint256 denominator)\n    internal\n    pure\n    returns (uq112x112 memory)\n  {\n    require(denominator > 0, \"FixedPoint::fraction: division by zero\");\n    if (numerator == 0) return FixedPoint.uq112x112(0);\n\n    if (numerator <= type(uint144).max) {\n      uint256 result = (numerator << RESOLUTION) / denominator;\n      require(result <= type(uint224).max, \"FixedPoint::fraction: overflow\");\n      return uq112x112(uint224(result));\n    } else {\n      uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\n      require(result <= type(uint224).max, \"FixedPoint::fraction: overflow\");\n      return uq112x112(uint224(result));\n    }\n  }\n}\n"
      },
      "contracts/interfaces/IStableLPToken.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport \"./ISwap.sol\";\n\ninterface IStableLPToken {\n  function swap() external view returns (ISwap);\n\n  function totalSupply() external view returns (uint256);\n}\n"
      },
      "contracts/libraries/math/FullMath.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.15;\n\n// solhint-disable no-inline-assembly, reason-string, max-line-length\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = a * b\n            // Compute the product mod 2**256 and mod 2**256 - 1\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2**256 + prod0\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(a, b, not(0))\n                prod0 := mul(a, b)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division\n            if (prod1 == 0) {\n                require(denominator > 0);\n                assembly {\n                    result := div(prod0, denominator)\n                }\n                return result;\n            }\n\n            // Make sure the result is less than 2**256.\n            // Also prevents denominator == 0\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0]\n            // Compute remainder using mulmod\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(a, b, denominator)\n            }\n            // Subtract 256 bit number from 512 bit number\n            assembly {\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator\n            // Compute largest power of two divisor of denominator.\n            // Always >= 1.\n            // EDIT for 0.8 compatibility:\n            // see: https://ethereum.stackexchange.com/questions/96642/unary-operator-cannot-be-applied-to-type-uint256\n            uint256 twos = denominator & (~denominator + 1);\n\n            // Divide denominator by power of two\n            assembly {\n                denominator := div(denominator, twos)\n            }\n\n            // Divide [prod1 prod0] by the factors of two\n            assembly {\n                prod0 := div(prod0, twos)\n            }\n            // Shift in bits from prod1 into prod0. For this we need\n            // to flip `twos` such that it is 2**256 / twos.\n            // If twos is zero, then it becomes one\n            assembly {\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\n            uint256 inv = (3 * denominator) ^ 2;\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - denominator * inv; // inverse mod 2**8\n            inv *= 2 - denominator * inv; // inverse mod 2**16\n            inv *= 2 - denominator * inv; // inverse mod 2**32\n            inv *= 2 - denominator * inv; // inverse mod 2**64\n            inv *= 2 - denominator * inv; // inverse mod 2**128\n            inv *= 2 - denominator * inv; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of denominator. This will give us the\n            // correct result modulo 2**256. Since the precoditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inv;\n            return result;\n        }\n    }\n\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        if (mulmod(a, b, denominator) > 0) {\n            require(result < type(uint256).max);\n            result++;\n        }\n    }\n}"
      },
      "contracts/pricers/StablePoolPricer.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\nimport \"../interfaces/IAssetPricer.sol\";\nimport \"../interfaces/ERC20/IERC20.sol\";\nimport \"../interfaces/ISwap.sol\";\nimport \"../libraries/math/FixedPoint.sol\";\nimport \"../interfaces/IStableLPToken.sol\";\n\n/**\n * Bonding calculator for stable pool\n */\ncontract StablePoolPricer is IAssetPricer {\n  using FixedPoint for *;\n\n  address public immutable QUOTE;\n\n  constructor(address _QUOTE) {\n    require(_QUOTE != address(0));\n    QUOTE = _QUOTE;\n  }\n\n  // calculates the liquidity value denominated in the provided token\n  // uses the 0.01% inputAmount for that calculation\n  // note that we never use the actual LP as input as the swap contains the LP address\n  // and is also used to extract the balances\n  function getTotalValue(address _lpAddress)\n    public\n    view\n    returns (uint256 _value)\n  {\n    ISwap swap = IStableLPToken(_lpAddress).swap();\n    IERC20[] memory tokens = swap.getPooledTokens();\n    uint256[] memory reserves = swap.getTokenBalances();\n    for (uint8 i = 0; i < reserves.length; i++) {\n      address tokenAddr = address(tokens[i]);\n      if (tokenAddr != QUOTE) {\n        _value +=\n          swap.calculateSwapGivenIn(tokenAddr, QUOTE, reserves[i] / 10000) *\n          10000;\n      } else {\n        _value += reserves[i];\n      }\n    }\n  }\n\n  function valuation(address _lpAddress, uint256 amount_)\n    external\n    view\n    override\n    returns (uint256 _value)\n  {\n    uint256 totalValue = getTotalValue(_lpAddress);\n    uint256 totalSupply = IStableLPToken(_lpAddress).totalSupply();\n\n    _value =\n      (totalValue *\n        FixedPoint.fraction(amount_, totalSupply).decode112with18()) /\n      1e18;\n  }\n\n  function markdown(address _lpAddress) external view returns (uint256) {\n    return getTotalValue(_lpAddress);\n  }\n}\n"
      },
      "contracts/pricers/WeightedPairPricer.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\nimport \"../interfaces/IAssetPricer.sol\";\nimport \"../interfaces/ERC20/IERC20.sol\";\nimport \"../interfaces/IWeightedPair.sol\";\nimport \"../libraries/math/FixedPoint.sol\";\nimport \"../libraries/math/SqrtMath.sol\";\n\n/**\n * Bonding calculator for weighted pairs\n */\ncontract WeightedPairPricer is IAssetPricer {\n  using FixedPoint for *;\n\n  // address that is used for the quote of the provided pool\n  address public immutable QUOTE;\n\n  constructor(address _QUOTE) {\n    require(_QUOTE != address(0));\n    QUOTE = _QUOTE;\n  }\n\n  /**\n   * note for general pairs the price does not necessarily satisfy the conditon\n   * that the lp value consists 50% of the one and the other token since the mid\n   * price is the quotient of the reserves. That is not necessarily the case for\n   * general pairs, therefore, we have to calculate the price separately and apply it\n   * to the reserve amount for conversion\n   * - calculates the total liquidity value denominated in the provided token\n   * - uses the 1bps ouytput reserves for that calculation to avoid slippage to\n   *   have a too large impact\n   * - the sencond token input argument is ignored when using pools with only 2 tokens\n   * @param _pair general pair that has the RequiemSwap interface implemented\n   *  - the value is calculated as the geometric average of input and output\n   *  - is consistent with the uniswapV2-type case\n   */\n  function getTotalValue(address _pair) public view returns (uint256 _value) {\n    IWeightedPair.ReserveData memory pairData = IWeightedPair(_pair)\n      .getReserves();\n    (uint32 weight0, uint32 weight1, , ) = IWeightedPair(_pair).getParameters();\n\n    // In case of both weights being 50, it is equivalent to\n    // the UniswapV2 variant. If the weights are different, we define the valuation by\n    // scaling the reserve up or down dependent on the weights and the use the product as\n    // adjusted constant product. We will use the conservative estimation of the price - we upscale\n    // such that the reflected equivalent pool is a uniswapV2 with the higher liquidity that pruduces\n    // the same price of the Requiem token as the weighted pool.\n    if (QUOTE == IWeightedPair(_pair).token0()) {\n      _value =\n        pairData.reserve0 +\n        (pairData.vReserve0 * weight1 * pairData.reserve1) /\n        (weight0 * pairData.vReserve1);\n    } else {\n      _value =\n        pairData.reserve1 +\n        (pairData.vReserve1 * weight0 * pairData.reserve0) /\n        (weight1 * pairData.vReserve0);\n    }\n    // standardize to 18 decimals\n    _value *= 10**(18 - IERC20(QUOTE).decimals());\n  }\n\n  /**\n   * - calculates the value in QUOTE that backs reqt 1:1 of the input LP amount provided\n   * @param _pair general pair that has the RequiemSwap interface implemented\n   * @param amount_ the amount of LP to price for the backing\n   *  - is consistent with the uniswapV2-type case\n   */\n  function valuation(address _pair, uint256 amount_)\n    external\n    view\n    override\n    returns (uint256 _value)\n  {\n    uint256 totalValue = getTotalValue(_pair);\n    uint256 totalSupply = IWeightedPair(_pair).totalSupply();\n\n    _value = (totalValue * amount_) / totalSupply;\n  }\n\n  // markdown function for bond valuation - no discounting fo regular pairs\n  function markdown(address _pair) external view returns (uint256) {\n    return getTotalValue(_pair);\n  }\n}\n"
      },
      "contracts/interfaces/IWeightedPair.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\n// solhint-disable func-name-mixedcase\n\ninterface IWeightedPair {\n  struct ReserveData {\n    uint256 reserve0;\n    uint256 reserve1;\n    uint256 vReserve0;\n    uint256 vReserve1;\n  }\n\n  function totalSupply() external view returns (uint256);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function getReserves()\n    external\n    view\n    returns (ReserveData calldata reserveData);\n\n  function getParameters()\n    external\n    view\n    returns (\n      uint32 _tokenWeight0,\n      uint32 _tokenWeight1,\n      uint32 _swapFee,\n      uint32 _amp\n    );\n}\n"
      },
      "contracts/libraries/math/SqrtMath.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nlibrary SqrtMath {\n  function sqrrt(uint256 a) internal pure returns (uint256 c) {\n    if (a > 3) {\n      c = a;\n      uint256 b = a / 2 + 1;\n      while (b < c) {\n        c = b;\n        b = ((a / b) + b) / 2;\n      }\n    } else if (a != 0) {\n      c = 1;\n    }\n  }\n}\n"
      },
      "contracts/pricers/RequiemPricer.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\nimport \"../interfaces/IAssetPricer.sol\";\nimport \"../interfaces/ERC20/IERC20.sol\";\nimport \"../interfaces/IWeightedPair.sol\";\nimport \"../interfaces/ISwap.sol\";\nimport \"../libraries/math/FixedPoint.sol\";\nimport \"../libraries/math/SqrtMath.sol\";\nimport \"../libraries/math/FullMath.sol\";\n\n/**\n * Bonding calculator for weighted pairs\n */\ncontract RequiemPricer is IAssetPricer {\n  using FixedPoint for *;\n\n  address public immutable REQ;\n\n  constructor(address _REQ) {\n    require(_REQ != address(0));\n    REQ = _REQ;\n  }\n\n  /**\n   * note for general pairs the price does not necessarily satisfy the conditon\n   * that the lp value consists 50% of the one and the other token since the mid\n   * price is the quotient of the reserves. That is not necessarily the case for\n   * general pairs, therefore, we have to calculate the price separately and apply it\n   * to the reserve amount for conversion\n   * - calculates the total liquidity value denominated in the provided token\n   * - uses the 1bps ouytput reserves for that calculation to avoid slippage to\n   *   have a too large impact\n   * - the sencond token input argument is ignored when using pools with only 2 tokens\n   * @param _pair pair that includes requiem token\n   *  - the value of the requiem reserve is assumed at 1 unit of quote\n   *  - is consistent with the uniswapV2-type case\n   */\n  function getTotalValue(address _pair) public view returns (uint256 _value) {\n    IWeightedPair.ReserveData memory pairData = IWeightedPair(_pair)\n      .getReserves();\n\n    uint256 quoteMultiplier = 10 **\n      (18 - IERC20(IWeightedPair(_pair).token1()).decimals());\n\n    if (REQ == IWeightedPair(_pair).token1()) {\n      _value = pairData.reserve0 * quoteMultiplier + pairData.reserve1;\n    } else {\n      _value = pairData.reserve1 * quoteMultiplier + pairData.reserve0;\n    }\n  }\n\n  /**\n   * - calculates the value in reqt of the input LP amount provided\n   * @param _pair general pair that has the RequiemSwap interface implemented\n   * @param amount_ the amount of LP to price in REQ\n   *  - is consistent with the uniswapV2-type case\n   */\n  function valuation(address _pair, uint256 amount_)\n    external\n    view\n    override\n    returns (uint256 _value)\n  {\n    uint256 totalValue = getTotalValue(_pair);\n    uint256 totalSupply = IWeightedPair(_pair).totalSupply();\n\n    _value = (totalValue * amount_) / totalSupply;\n  }\n\n  // markdown function for bond valuation\n  function markdown(address _pair) external view returns (uint256) {\n    IWeightedPair.ReserveData memory pairData = IWeightedPair(_pair)\n      .getReserves();\n\n    uint256 reservesOther = REQ ==\n      IWeightedPair(_pair).token0()\n      ? pairData.reserve1\n      : pairData.reserve0;\n\n    // adjusted markdown scaling up the reserve as the trading mechanism allows\n    // for lower valuation for reqt reserve\n    return\n      (2 * reservesOther * (10**IERC20(REQ).decimals())) / getTotalValue(_pair);\n  }\n}\n"
      },
      "contracts/mocks/TestPair.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport \"../interfaces/IWeightedPair.sol\";\nimport \"./ERC20.sol\";\n\n// solhint-disable func-name-mixedcase\n\ncontract TestPair is ERC20, IWeightedPair {\n  ReserveData public reserveData;\n  address public token0;\n  address public token1;\n  uint32 public weight0;\n  uint32 public weight1;\n\n  constructor(\n    address _token0,\n    address _token1,\n    uint32 _weight0,\n    uint32 _weight1\n  ) ERC20(\"Test Pair\", \"TP\", 18) {\n    token0 = _token0;\n    token1 = _token1;\n    weight0 = _weight0;\n    weight1 = _weight1;\n\n    reserveData = ReserveData(0, 0, 0, 0);\n  }\n\n  function setReserves(\n    uint256 _reserves0,\n    uint256 _reserves1,\n    uint256 _vReserves0,\n    uint256 _vReserves1\n  ) public {\n    ReserveData memory _reserveData = ReserveData(\n      _reserves0,\n      _reserves1,\n      _vReserves0,\n      _vReserves1\n    );\n    reserveData = _reserveData;\n  }\n\n  function getReserves() external view returns (ReserveData memory) {\n    ReserveData memory _reserveData = IWeightedPair.ReserveData(\n      reserveData.reserve0,\n      reserveData.reserve1,\n      reserveData.vReserve0,\n      reserveData.vReserve1\n    );\n    return _reserveData;\n  }\n\n  function getParameters()\n    external\n    view\n    returns (\n      uint32 _tokenWeight0,\n      uint32 _tokenWeight1,\n      uint32 _swapFee,\n      uint32 _amp\n    )\n  {\n    _tokenWeight0 = weight0;\n    _tokenWeight1 = weight1;\n    _swapFee = 0;\n    _amp = 0;\n  }\n\n  function mint(address to, uint256 value) public virtual {\n    _mint(to, value);\n  }\n\n  function totalSupply()\n    public\n    view\n    override(ERC20, IWeightedPair)\n    returns (uint256)\n  {\n    return _totalSupply;\n  }\n\n  function decimals() public pure override returns (uint8) {\n    return 18;\n  }\n}\n"
      },
      "contracts/mocks/ERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport \"./Context.sol\";\nimport \"../interfaces/ERC20/IERC20.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is IERC20, Context {\n    mapping(address => uint256) internal _balances;\n\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    uint256 internal _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
      },
      "contracts/mocks/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}"
      },
      "contracts/mocks/MockREQ.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport \"./ERC20.sol\";\nimport \"../interfaces/IREQ.sol\";\nimport \"../libraries/Ownable.sol\";\n\ncontract MockREQ is ERC20, IREQ, Ownable {\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  uint256 public MAX_TOTAL_SUPPLY;\n\n  mapping(address => uint256) public minters; // minter's address => minter's max cap\n  mapping(address => uint256) public minters_minted;\n\n  /* ========== EVENTS ========== */\n  event MinterUpdate(address indexed account, uint256 cap);\n  event MaxTotalSupplyUpdated(uint256 _newCap);\n\n  constructor(uint256 _max_supp) Ownable() ERC20(\"Requiem\", \"REQ\", 18) {\n    MAX_TOTAL_SUPPLY = _max_supp;\n  }\n\n  /* ========== Modifiers =============== */\n\n  modifier onlyMinter() {\n    require(minters[msg.sender] > 0, \"Only minter can interact\");\n    _;\n  }\n\n  function _beforeTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _amount\n  ) internal override {\n    super._beforeTokenTransfer(_from, _to, _amount);\n    if (_from == address(0)) {\n      // When minting tokens\n      require(\n        totalSupply() + _amount <= MAX_TOTAL_SUPPLY,\n        \"Max total supply exceeded\"\n      );\n    }\n    if (_to == address(0)) {\n      // When burning tokens\n      require(\n        MAX_TOTAL_SUPPLY >= _amount,\n        \"Burn amount exceeds max total supply\"\n      );\n      MAX_TOTAL_SUPPLY -= _amount;\n    }\n  }\n\n  function mint(address to, uint256 value) external override onlyMinter {\n    _mint(to, value);\n  }\n\n  function burn(uint256 value) external override {\n    _burn(_msgSender(), value);\n  }\n\n  function burnFrom(address account, uint256 amount) external override {\n    uint256 currentAllowance = allowance(account, _msgSender());\n    require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n    unchecked {\n      _approve(account, _msgSender(), currentAllowance - amount);\n    }\n    _burn(account, amount);\n  }\n\n  /* ========== OWNER FUNCTIONS ========== */\n\n  function setMinter(address _account, uint256 _minterCap) external onlyOwner {\n    require(_account != address(0), \"invalid address\");\n    require(\n      minters_minted[_account] <= _minterCap,\n      \"Minter already minted a larger amount than new cap\"\n    );\n    minters[_account] = _minterCap;\n    emit MinterUpdate(_account, _minterCap);\n  }\n\n  function resetMaxTotalSupply(uint256 _newCap) external onlyOwner {\n    require(_newCap >= totalSupply(), \"_newCap is below current total supply\");\n    MAX_TOTAL_SUPPLY = _newCap;\n    emit MaxTotalSupplyUpdated(_newCap);\n  }\n}\n"
      },
      "contracts/interfaces/IREQ.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.8.15;\n\nimport \"./ERC20/IERC20.sol\";\n\ninterface IREQ is IERC20 {\n    function mint(address account_, uint256 amount_) external;\n\n    function burn(uint256 amount) external;\n\n    function burnFrom(address account_, uint256 amount_) external;\n}\n"
      },
      "contracts/libraries/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"../interfaces/IOwnable.sol\";\n\ncontract Ownable is IOwnable {\n    \n  address internal _owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  constructor () {\n    _owner = msg.sender;\n    emit OwnershipTransferred( address(0), _owner );\n  }\n\n  function owner() public view override returns (address) {\n    return _owner;\n  }\n\n  modifier onlyOwner() {\n    require( _owner == msg.sender, \"Ownable: caller is not the owner\" );\n    _;\n  }\n\n  function renounceOwnership() public virtual override onlyOwner() {\n    emit OwnershipTransferred( _owner, address(0) );\n    _owner = address(0);\n  }\n\n  function transferOwnership( address newOwner_ ) public virtual override onlyOwner() {\n    require( newOwner_ != address(0), \"Ownable: new owner is the zero address\");\n    emit OwnershipTransferred( _owner, newOwner_ );\n    _owner = newOwner_;\n  }\n}"
      },
      "contracts/interfaces/IOwnable.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\ninterface IOwnable {\n  function owner() external view returns (address);\n\n  function renounceOwnership() external;\n  \n  function transferOwnership( address newOwner_ ) external;\n}"
      },
      "contracts/mocks/MockERC20.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport \"./ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    uint8 _decimals\n  ) ERC20(_name, _symbol, _decimals) {}\n\n  function mint(address to, uint256 value) public virtual {\n    _mint(to, value);\n  }\n\n  function burn(address from, uint256 value) public virtual {\n    _burn(from, value);\n  }\n}\n"
      },
      "contracts/mocks/MockGreq.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n//import {IgREQ} from \"../interfaces/IgREQ.sol\";\nimport \"./MockERC20.sol\";\n\n// TODO fulfills IgREQ but is not inheriting because of dependency issues\ncontract MockGReq is MockERC20 {\n    /* ========== CONSTRUCTOR ========== */\n\n    uint256 public immutable index;\n\n    constructor(uint256 _initIndex) MockERC20(\"Governance REQ\", \"gREQ\", 18) {\n        index = _initIndex;\n    }\n\n    function migrate(address _staking, address _sReq) external {}\n\n    function balanceFrom(uint256 _amount) public view returns (uint256) {\n        return (_amount * index) / 10**decimals();\n    }\n\n    function balanceTo(uint256 _amount) public view returns (uint256) {\n        return (_amount * (10**decimals())) / index;\n    }\n}\n"
      },
      "contracts/pricers/TrivialPricer.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\nimport \"../interfaces/IAssetPricer.sol\";\nimport \"../interfaces/ERC20/IERC20.sol\";\n\n/**\n * Pricer returning\n */\ncontract TrivialPricer is IAssetPricer {\n  constructor() {}\n\n  /**\n   * note normalizes asset value to 18 decimals\n   * @param _asset pair that includes requiem token\n   *  - the value of the requiem reserve is assumed at 1 unit of quote\n   *  - is consistent with the uniswapV2-type case\n   */\n  function getTotalValue(address _asset) public view returns (uint256 _value) {\n    _value =\n      IERC20(_asset).totalSupply() *\n      10**(18 - IERC20(_asset).decimals());\n  }\n\n  /**\n   * - calculates the value in reqt of the input LP amount provided\n   * @param _asset general pair that has the RequiemSwap interface implemented\n   * @param _amount the amount of LP to price in REQ\n   *  - is consistent with the uniswapV2-type case\n   */\n  function valuation(address _asset, uint256 _amount)\n    external\n    view\n    override\n    returns (uint256 _value)\n  {\n    _value = _amount * 10**(18 - IERC20(_asset).decimals());\n  }\n\n  // markdown function for bond valuation\n  function markdown(address _asset) external view returns (uint256) {\n    return getTotalValue(_asset);\n  }\n}\n"
      },
      "contracts/interfaces/IsREQ.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.8.5;\n\nimport \"./ERC20/IERC20.sol\";\n\ninterface IsREQ is IERC20 {\n    function rebase(uint256 reqProfit_, uint256 epoch_) external returns (uint256);\n\n    function circulatingSupply() external view returns (uint256);\n\n    function gonsForBalance(uint256 amount) external view returns (uint256);\n\n    function balanceForGons(uint256 gons) external view returns (uint256);\n\n    function index() external view returns (uint256);\n\n    function toG(uint256 amount) external view returns (uint256);\n\n    function fromG(uint256 amount) external view returns (uint256);\n\n    function changeDebt(\n        uint256 amount,\n        address debtor,\n        bool add\n    ) external;\n\n    function debtBalances(address _address) external view returns (uint256);\n}\n"
      },
      "contracts/interfaces/ERC20/IRewardToken.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IERC20.sol\";\n\ninterface IRewardToken is IERC20 {\n    function mint(address _recipient, uint256 _amount) external;\n}\n"
      },
      "contracts/interfaces/IBondDepository.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.8.15;\n\nimport \"./ERC20/IERC20.sol\";\n\ninterface IBondDepository {\n  // Info about each type of market\n  struct Market {\n    uint256 capacity; // capacity remaining\n    IERC20 quoteToken; // token to accept as payment\n    bool capacityInQuote; // capacity limit is in payment token (true) or in REQ (false, default)\n    uint256 totalDebt; // total debt from market\n    uint256 maxPayout; // max tokens in/out (determined by capacityInQuote false/true, respectively)\n    uint256 sold; // base tokens out\n    uint256 purchased; // quote tokens in\n  }\n\n  // Info for creating new markets\n  struct Terms {\n    bool fixedTerm; // fixed term or fixed expiration\n    uint256 controlVariable; // scaling variable for price\n    uint48 vesting; // length of time from deposit to maturity if fixed-term\n    uint48 conclusion; // timestamp when market no longer offered (doubles as time when market matures if fixed-expiry)\n    uint256 maxDebt; // 18 decimal debt maximum in REQ\n  }\n\n  // Additional info about market.\n  struct Metadata {\n    uint48 lastTune; // last timestamp when control variable was tuned\n    uint48 lastDecay; // last timestamp when market was created and debt was decayed\n    uint48 length; // time from creation to conclusion. used as speed to decay debt.\n    uint48 depositInterval; // target frequency of deposits\n    uint48 tuneInterval; // frequency of tuning\n    uint8 quoteDecimals; // decimals of quote token\n  }\n\n  // Control variable adjustment data\n  struct Adjustment {\n    uint256 change;\n    uint48 lastAdjustment;\n    uint48 timeToAdjusted;\n    bool active;\n  }\n\n  /**\n   * @notice deposit market\n   * @param _bid uint256\n   * @param _amount uint256\n   * @param _maxPrice uint256\n   * @param _user address\n   * @param _referral address\n   * @return payout_ uint256\n   * @return expiry_ uint256\n   * @return index_ uint256\n   */\n  function deposit(\n    uint256 _bid,\n    uint256 _amount,\n    uint256 _maxPrice,\n    address _user,\n    address _referral\n  )\n    external\n    returns (\n      uint256 payout_,\n      uint256 expiry_,\n      uint256 index_\n    );\n\n  function create(\n    IERC20 _quoteToken, // token used to deposit\n    uint256[3] memory _market, // [capacity, initial price]\n    bool[2] memory _booleans, // [capacity in quote, fixed term]\n    uint256[2] memory _terms, // [vesting, conclusion]\n    uint32[2] memory _intervals // [deposit interval, tune interval]\n  ) external returns (uint256 id_);\n\n  function close(uint256 _id) external;\n\n  function isLive(uint256 _bid) external view returns (bool);\n\n  function liveMarkets() external view returns (uint256[] memory);\n\n  function liveMarketsFor(address _quoteToken)\n    external\n    view\n    returns (uint256[] memory);\n\n  function payoutFor(uint256 _amount, uint256 _bid)\n    external\n    view\n    returns (uint256);\n\n  function marketPrice(uint256 _bid) external view returns (uint256);\n\n  function currentDebt(uint256 _bid) external view returns (uint256);\n\n  function debtRatio(uint256 _bid) external view returns (uint256);\n\n  function debtDecay(uint256 _bid) external view returns (uint256);\n}\n"
      },
      "contracts/BondDepository.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.15;\n\nimport \"./libraries/types/UserTermsKeeper.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./interfaces/ERC20/IERC20Metadata.sol\";\nimport \"./interfaces/IBondDepository.sol\";\n\n// solhint-disable  max-line-length\n\n/// @title Requiem Bond Depository\n/// @author Requiem: Achthar; Olympus DAO: Zeus, Indigo\n\ncontract BondDepository is IBondDepository, UserTermsKeeper {\n    /* ======== DEPENDENCIES ======== */\n\n    using SafeERC20 for IERC20;\n\n    /* ======== EVENTS ======== */\n\n    event CreateMarket(uint256 indexed id, address indexed baseToken, address indexed quoteToken, uint256 initialPrice);\n    event CloseMarket(uint256 indexed id);\n    event Bond(uint256 indexed id, uint256 amount, uint256 price);\n    event Tuned(uint256 indexed id, uint256 oldControlVariable, uint256 newControlVariable);\n\n    /* ======== STATE VARIABLES ======== */\n\n    // Storage\n    Market[] public markets; // persistent market data\n    Terms[] public terms; // deposit construction data\n    Metadata[] public metadata; // extraneous market data\n    mapping(uint256 => Adjustment) public adjustments; // control variable changes\n\n    // Queries\n    mapping(address => uint256[]) public marketsForQuote; // market IDs for quote token\n\n    /* ======== CONSTRUCTOR ======== */\n\n    constructor(\n        IERC20 _req,\n        address _treasury\n    ) UserTermsKeeper(_req, _treasury) {}\n\n    /* ======== DEPOSIT ======== */\n\n    /**\n     * @notice             deposit quote tokens in exchange for a bond from a specified market\n     * @param _id          the ID of the market\n     * @param _amount      the amount of quote token to spend\n     * @param _maxPrice    the maximum price at which to buy\n     * @param _user        the recipient of the payout\n     * @param _referral    the front end operator address\n     * @return payout_     the amount of gREQ due\n     * @return expiry_     the timestamp at which payout is redeemable\n     * @return index_      the user index of the Terms (used to redeem or query information)\n     */\n    function deposit(\n        uint256 _id,\n        uint256 _amount,\n        uint256 _maxPrice,\n        address _user,\n        address _referral\n    )\n        external\n        override\n        returns (\n            uint256 payout_,\n            uint256 expiry_,\n            uint256 index_\n        )\n    {\n        Market storage market = markets[_id];\n        Terms memory term = terms[_id];\n        uint48 currentTime = uint48(block.timestamp);\n\n        // Markets end at a defined timestamp\n        // |-------------------------------------| t\n        require(currentTime < term.conclusion, \"Depository: market concluded\");\n\n        // Debt and the control variable decay over time\n        _decay(_id, currentTime);\n\n        // Users input a maximum price, which protects them from price changes after\n        // entering the mempool. max price is a slippage mitigation measure\n        uint256 price = _marketPrice(_id);\n        require(price <= _maxPrice, \"Depository: more than max price\");\n\n        /**\n         * payout for the deposit = amount / price\n         *\n         * where\n         * payout = REQ out\n         * amount = quote tokens in\n         * price = quote tokens : req (i.e. 42069 DAI : REQ)\n         *\n         * REQ decimals is supposed to match price decimals\n         */\n        payout_ = ((_amount * 10**(2 * req.decimals())) / price) / (10**metadata[_id].quoteDecimals);\n\n        // markets have a max payout amount, capping size because deposits\n        // do not experience slippage. max payout is recalculated upon tuning\n        require(payout_ <= market.maxPayout, \"Depository: max size exceeded\");\n\n        /*\n         * each market is initialized with a capacity\n         *\n         * this is either the number of REQ that the market can sell\n         * (if capacity in quote is false),\n         *\n         * or the number of quote tokens that the market can buy\n         * (if capacity in quote is true)\n         */\n        market.capacity -= market.capacityInQuote ? _amount : payout_;\n\n        /**\n         * bonds mature with a cliff at a set timestamp\n         * prior to the expiry timestamp, no payout tokens are accessible to the user\n         * after the expiry timestamp, the entire payout can be redeemed\n         *\n         * there are two types of bonds: fixed-term and fixed-expiration\n         *\n         * fixed-term bonds mature in a set amount of time from deposit\n         * i.e. term = 1 week. when alice deposits on day 1, her bond\n         * expires on day 8. when bob deposits on day 2, his bond expires day 9.\n         *\n         * fixed-expiration bonds mature at a set timestamp\n         * i.e. expiration = day 10. when alice deposits on day 1, her term\n         * is 9 days. when bob deposits on day 2, his term is 8 days.\n         */\n        expiry_ = term.fixedTerm ? term.vesting + currentTime : term.vesting;\n\n        // markets keep track of how many quote tokens have been\n        // purchased, and how much REQ has been sold\n        market.purchased += _amount;\n        market.sold += payout_;\n\n        // incrementing total debt raises the price of the next bond\n        market.totalDebt += payout_;\n\n        emit Bond(_id, _amount, price);\n\n        /**\n         * user data is stored as Termss. these are isolated array entries\n         * storing the amount due, the time created, the time when payout\n         * is redeemable, the time when payout was redeemed, and the ID\n         * of the market deposited into\n         */\n        index_ = addTerms(_user, payout_, uint48(expiry_), uint48(_id), _referral);\n\n        // transfer payment to treasury\n        market.quoteToken.safeTransferFrom(msg.sender, address(treasury), _amount);\n\n        // if max debt is breached, the market is closed\n        // this a circuit breaker\n        if (term.maxDebt < market.totalDebt) {\n            market.capacity = 0;\n            emit CloseMarket(_id);\n        } else {\n            // if market will continue, the control variable is tuned to hit targets on time\n            _tune(_id, currentTime);\n        }\n    }\n\n    /**\n     * @notice             decay debt, and adjust control variable if there is an active change\n     * @param _id          ID of market\n     * @param _time        uint48 timestamp (saves gas when passed in)\n     */\n    function _decay(uint256 _id, uint48 _time) internal {\n        // Debt decay\n\n        /*\n         * Debt is a time-decayed sum of tokens spent in a market\n         * Debt is added when deposits occur and removed over time\n         * |\n         * |    debt falls with\n         * |   / \\  inactivity       / \\\n         * | /     \\              /\\/    \\\n         * |         \\           /         \\\n         * |           \\      /\\/            \\\n         * |             \\  /  and rises       \\\n         * |                with deposits\n         * |\n         * |------------------------------------| t\n         */\n        markets[_id].totalDebt -= debtDecay(_id);\n        metadata[_id].lastDecay = _time;\n\n        // Control variable decay\n\n        // The bond control variable is continually tuned. When it is lowered (which\n        // lowers the market price), the change is carried out smoothly over time.\n        if (adjustments[_id].active) {\n            Adjustment storage adjustment = adjustments[_id];\n\n            (uint256 adjustBy, uint48 secondsSince, bool stillActive) = _controlDecay(_id);\n            terms[_id].controlVariable -= adjustBy;\n\n            if (stillActive) {\n                adjustment.change -= adjustBy;\n                adjustment.timeToAdjusted -= secondsSince;\n                adjustment.lastAdjustment = _time;\n            } else {\n                adjustment.active = false;\n            }\n        }\n    }\n\n    /**\n     * @notice             auto-adjust control variable to hit capacity/spend target\n     * @param _id          ID of market\n     * @param _time        uint48 timestamp (saves gas when passed in)\n     */\n    function _tune(uint256 _id, uint48 _time) internal {\n        Metadata memory meta = metadata[_id];\n\n        if (_time >= meta.lastTune + meta.tuneInterval) {\n            Market memory market = markets[_id];\n\n            // compute seconds remaining until market will conclude\n            uint256 timeRemaining = terms[_id].conclusion - _time;\n            uint256 price = _marketPrice(_id);\n\n            // standardize capacity into an base token amount\n            // req decimals + price decimals\n            uint256 capacity = market.capacityInQuote\n                ? ((market.capacity * (10**(2 * req.decimals()))) / price) / (10**meta.quoteDecimals)\n                : market.capacity;\n\n            /**\n             * calculate the correct payout to complete on time assuming each bond\n             * will be max size in the desired deposit interval for the remaining time\n             *\n             * i.e. market has 10 days remaining. deposit interval is 1 day. capacity\n             * is 10,000 REQ. max payout would be 1,000 REQ (10,000 * 1 / 10).\n             */\n            markets[_id].maxPayout = uint256((capacity * meta.depositInterval) / timeRemaining);\n\n            // calculate the ideal total debt to satisfy capacity in the remaining time\n            uint256 targetDebt = (capacity * meta.length) / timeRemaining;\n\n            // derive a new control variable from the target debt and current supply\n            uint256 newControlVariable = uint256((price * treasury.baseSupply()) / targetDebt);\n\n            emit Tuned(_id, terms[_id].controlVariable, newControlVariable);\n\n            if (newControlVariable >= terms[_id].controlVariable) {\n                terms[_id].controlVariable = newControlVariable;\n            } else {\n                // if decrease, control variable change will be carried out over the tune interval\n                // this is because price will be lowered\n                uint256 change = terms[_id].controlVariable - newControlVariable;\n                adjustments[_id] = Adjustment(change, _time, meta.tuneInterval, true);\n            }\n            metadata[_id].lastTune = _time;\n        }\n    }\n\n    /* ======== CREATE ======== */\n\n    /**\n     * @notice             creates a new market type\n     * @dev                current price should be in 9 decimals.\n     * @param _quoteToken  token used to deposit\n     * @param _market      [capacity (in REQ or quote), initial price / REQ (18 decimals), debt buffer (3 decimals)]\n     * @param _booleans    [capacity in quote, fixed term]\n     * @param _terms       [vesting length (if fixed term) or vested timestamp, conclusion timestamp]\n     * @param _intervals   [deposit interval (seconds), tune interval (seconds)]\n     * @return id_         ID of new bond market\n     */\n    function create(\n        IERC20 _quoteToken,\n        uint256[3] memory _market,\n        bool[2] memory _booleans,\n        uint256[2] memory _terms,\n        uint32[2] memory _intervals\n    ) external override onlyPolicy returns (uint256 id_) {\n        // the length of the program, in seconds\n        uint256 secondsToConclusion = _terms[1] - block.timestamp;\n\n        // the decimal count of the quote token\n        uint256 decimals = IERC20Metadata(address(_quoteToken)).decimals();\n\n        /*\n         * initial target debt is equal to capacity (this is the amount of debt\n         * that will decay over in the length of the program if price remains the same).\n         * it is converted into base token terms if passed in in quote token terms.\n         *\n         * 1e18 = req decimals (x) + initial price decimals (18)\n         */\n        uint256 targetDebt = uint256(_booleans[0] ? ((_market[0] * (10**(2 * req.decimals()))) / _market[1]) / 10**decimals : _market[0]);\n\n        /*\n         * max payout is the amount of capacity that should be utilized in a deposit\n         * interval. for example, if capacity is 1,000 REQ, there are 10 days to conclusion,\n         * and the preferred deposit interval is 1 day, max payout would be 100 REQ.\n         */\n        uint256 maxPayout = uint256((targetDebt * _intervals[0]) / secondsToConclusion);\n\n        /*\n         * max debt serves as a circuit breaker for the market. let's say the quote\n         * token is a stablecoin, and that stablecoin depegs. without max debt, the\n         * market would continue to buy until it runs out of capacity. this is\n         * configurable with a 3 decimal buffer (1000 = 1% above initial price).\n         * note that its likely advisable to keep this buffer wide.\n         * note that the buffer is above 100%. i.e. 10% buffer = initial debt * 1.1\n         */\n        uint256 maxDebt = targetDebt + ((targetDebt * _market[2]) / 1e5); // 1e5 = 100,000. 10,000 / 100,000 = 10%.\n\n        /*\n         * the control variable is set so that initial price equals the desired\n         * initial price. the control variable is the ultimate determinant of price,\n         * so we compute this last.\n         *\n         * price = control variable * debt ratio\n         * debt ratio = total debt / supply\n         * therefore, control variable = price / debt ratio\n         */\n        uint256 controlVariable = (_market[1] * treasury.baseSupply()) / targetDebt;\n\n        // depositing into, or getting info for, the created market uses this ID\n        id_ = markets.length;\n\n        markets.push(\n            Market({\n                quoteToken: _quoteToken,\n                capacityInQuote: _booleans[0],\n                capacity: _market[0],\n                totalDebt: targetDebt,\n                maxPayout: maxPayout,\n                purchased: 0,\n                sold: 0\n            })\n        );\n\n        terms.push(\n            Terms({\n                fixedTerm: _booleans[1],\n                vesting: uint48(_terms[0]),\n                conclusion: uint48(_terms[1]),\n                controlVariable: controlVariable,\n                maxDebt: maxDebt\n            })\n        );\n\n        metadata.push(\n            Metadata({\n                lastTune: uint48(block.timestamp),\n                lastDecay: uint48(block.timestamp),\n                length: uint48(secondsToConclusion),\n                depositInterval: _intervals[0],\n                tuneInterval: _intervals[1],\n                quoteDecimals: uint8(decimals)\n            })\n        );\n\n        marketsForQuote[address(_quoteToken)].push(id_);\n\n        emit CreateMarket(id_, address(req), address(_quoteToken), _market[1]);\n    }\n\n    /**\n     * @notice             disable existing market\n     * @param _id          ID of market to close\n     */\n    function close(uint256 _id) external override onlyPolicy {\n        terms[_id].conclusion = uint48(block.timestamp);\n        markets[_id].capacity = 0;\n        emit CloseMarket(_id);\n    }\n\n    /* ======== EXTERNAL VIEW ======== */\n\n    /**\n     * @notice             calculate current market price of quote token in base token\n     * @dev                accounts for debt and control variable decay since last deposit (vs _marketPrice())\n     * @param _id          ID of market\n     * @return             price for market in REQ decimals\n     *\n     * price is derived from the equation\n     *\n     * p = cv * dr\n     *\n     * where\n     * p = price\n     * cv = control variable\n     * dr = debt ratio\n     *\n     * dr = d / s\n     *\n     * where\n     * d = debt\n     * s = supply of token at market creation\n     *\n     * d -= ( d * (dt / l) )\n     *\n     * where\n     * dt = change in time\n     * l = length of program\n     */\n    function marketPrice(uint256 _id) public view override returns (uint256) {\n        return (currentControlVariable(_id) * debtRatio(_id)) / (10**metadata[_id].quoteDecimals);\n    }\n\n    /**\n     * @notice             payout due for amount of quote tokens\n     * @dev                accounts for debt and control variable decay so it is up to date\n     * @param _amount      amount of quote tokens to spend\n     * @param _id          ID of market\n     * @return             amount of REQ to be paid in REQ decimals\n     *\n     * @dev we assume that the market price decimals and req decimals match (that is why we use 2 * req decimals)\n     */\n    function payoutFor(uint256 _amount, uint256 _id) external view override returns (uint256) {\n        Metadata memory meta = metadata[_id];\n        return (_amount * 10**(2 * req.decimals())) / marketPrice(_id) / 10**meta.quoteDecimals;\n    }\n\n    /**\n     * @notice             calculate current ratio of debt to supply\n     * @dev                uses current debt, which accounts for debt decay since last deposit (vs _debtRatio())\n     * @param _id          ID of market\n     * @return             debt ratio for market in quote decimals\n     */\n    function debtRatio(uint256 _id) public view override returns (uint256) {\n        return (currentDebt(_id) * (10**metadata[_id].quoteDecimals)) / treasury.baseSupply();\n    }\n\n    /**\n     * @notice             calculate debt factoring in decay\n     * @dev                accounts for debt decay since last deposit\n     * @param _id          ID of market\n     * @return             current debt for market in REQ decimals\n     */\n    function currentDebt(uint256 _id) public view override returns (uint256) {\n        return markets[_id].totalDebt - debtDecay(_id);\n    }\n\n    /**\n     * @notice             amount of debt to decay from total debt for market ID\n     * @param _id          ID of market\n     * @return             amount of debt to decay\n     */\n    function debtDecay(uint256 _id) public view override returns (uint256) {\n        Metadata memory meta = metadata[_id];\n\n        uint256 secondsSince = block.timestamp - meta.lastDecay;\n\n        return (markets[_id].totalDebt * secondsSince) / meta.length;\n    }\n\n    /**\n     * @notice             up to date control variable\n     * @dev                accounts for control variable adjustment\n     * @param _id          ID of market\n     * @return             control variable for market in REQ decimals\n     */\n    function currentControlVariable(uint256 _id) public view returns (uint256) {\n        (uint256 decay, , ) = _controlDecay(_id);\n        return terms[_id].controlVariable - decay;\n    }\n\n    /**\n     * @notice             is a given market accepting deposits\n     * @param _id          ID of market\n     */\n    function isLive(uint256 _id) public view override returns (bool) {\n        return (markets[_id].capacity != 0 && terms[_id].conclusion > block.timestamp);\n    }\n\n    /**\n     * @notice returns an array of all active market IDs\n     */\n    function liveMarkets() external view override returns (uint256[] memory) {\n        uint256 num;\n        for (uint256 i = 0; i < markets.length; i++) {\n            if (isLive(i)) num++;\n        }\n\n        uint256[] memory ids = new uint256[](num);\n        uint256 nonce;\n        for (uint256 i = 0; i < markets.length; i++) {\n            if (isLive(i)) {\n                ids[nonce] = i;\n                nonce++;\n            }\n        }\n        return ids;\n    }\n\n    /**\n     * @notice             returns an array of all active market IDs for a given quote token\n     * @param _token       quote token to check for\n     */\n    function liveMarketsFor(address _token) external view override returns (uint256[] memory) {\n        uint256[] memory mkts = marketsForQuote[_token];\n        uint256 num;\n\n        for (uint256 i = 0; i < mkts.length; i++) {\n            if (isLive(mkts[i])) num++;\n        }\n\n        uint256[] memory ids = new uint256[](num);\n        uint256 nonce;\n\n        for (uint256 i = 0; i < mkts.length; i++) {\n            if (isLive(mkts[i])) {\n                ids[nonce] = mkts[i];\n                nonce++;\n            }\n        }\n        return ids;\n    }\n\n    /* ======== INTERNAL VIEW ======== */\n\n    /**\n     * @notice                  calculate current market price of quote token in base token\n     * @dev                     see marketPrice() for explanation of price computation\n     * @dev                     uses info from storage because data has been updated before call (vs marketPrice())\n     * @param _id               market ID\n     * @return                  price for market in REQ decimals\n     */\n    function _marketPrice(uint256 _id) internal view returns (uint256) {\n        return (terms[_id].controlVariable * _debtRatio(_id)) / (10**metadata[_id].quoteDecimals);\n    }\n\n    /**\n     * @notice                  calculate debt factoring in decay\n     * @dev                     uses info from storage because data has been updated before call (vs debtRatio())\n     * @param _id               market ID\n     * @return                  current debt for market in quote decimals\n     */\n    function _debtRatio(uint256 _id) internal view returns (uint256) {\n        return (markets[_id].totalDebt * (10**metadata[_id].quoteDecimals)) / treasury.baseSupply();\n    }\n\n    /**\n     * @notice                  amount to decay control variable by\n     * @param _id               ID of market\n     * @return decay_           change in control variable\n     * @return secondsSince_    seconds since last change in control variable\n     * @return active_          whether or not change remains active\n     */\n    function _controlDecay(uint256 _id)\n        internal\n        view\n        returns (\n            uint256 decay_,\n            uint48 secondsSince_,\n            bool active_\n        )\n    {\n        Adjustment memory info = adjustments[_id];\n        if (!info.active) return (0, 0, false);\n\n        secondsSince_ = uint48(block.timestamp) - info.lastAdjustment;\n\n        active_ = secondsSince_ < info.timeToAdjusted;\n        decay_ = active_ ? (info.change * secondsSince_) / info.timeToAdjusted : info.change;\n    }\n}\n"
      },
      "contracts/libraries/types/UserTermsKeeper.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"./FrontEndRewarder.sol\";\nimport \"../../interfaces/ITreasury.sol\";\nimport \"../../interfaces/IUserTermsKeeper.sol\";\n\n// solhint-disable max-line-length\n\nabstract contract UserTermsKeeper is IUserTermsKeeper, FrontEndRewarder {\n    mapping(address => UserTerms[]) public userTerms; // user deposit data\n    mapping(address => mapping(uint256 => address)) private noteTransfers; // change note ownership\n\n\n    ITreasury internal treasury;\n\n    constructor(\n        IERC20 _req,\n        address _treasury\n    ) FrontEndRewarder(IAuthority(_treasury), _req) {\n        treasury = ITreasury(_treasury);\n    }\n\n    // if treasury address changes on authority, update it\n    function updateTreasury() external {\n        require(\n            msg.sender == authority.governor() ||\n                msg.sender == authority.guardian() ||\n                msg.sender == authority.policy(),\n            \"Only authorized\"\n        );\n        treasury = ITreasury(authority.vault());\n    }\n\n    /* ========== ADD ========== */\n\n    /**\n     * @notice             adds a new Terms for a user, stores the front end & DAO rewards, and mints & stakes payout & rewards\n     * @param _user        the user that owns the Terms\n     * @param _payout      the amount of REQ due to the user\n     * @param _expiry      the timestamp when the Terms is redeemable\n     * @param _marketID    the ID of the market deposited into\n     * @return index_      the index of the Terms in the user's array\n     */\n    function addTerms(\n        address _user,\n        uint256 _payout,\n        uint48 _expiry,\n        uint48 _marketID,\n        address _referral\n    ) internal returns (uint256 index_) {\n        // the index of the note is the next in the user's array\n        index_ = userTerms[_user].length;\n\n        // the new note is pushed to the user's array\n        userTerms[_user].push(\n            UserTerms({\n                payout: _payout,\n                created: uint48(block.timestamp),\n                matured: _expiry,\n                redeemed: 0,\n                marketID: _marketID\n            })\n        );\n\n        // front end operators can earn rewards by referring users\n        uint256 rewards = _giveRewards(_payout, _referral);\n\n        // mint and send to user\n        treasury.mint(_user, _payout + rewards);\n    }\n\n    /* ========== REDEEM ========== */\n\n    /**\n     * @notice             redeem userTerms for user\n     * @param _user        the user to redeem for\n     * @param _indexes     the note indexes to redeem\n     * @return payout_     sum of payout sent, in REQ\n     */\n    function redeem(\n        address _user,\n        uint256[] memory _indexes\n    ) public override returns (uint256 payout_) {\n        uint48 time = uint48(block.timestamp);\n\n        for (uint256 i = 0; i < _indexes.length; i++) {\n            (uint256 pay, bool matured) = pendingFor(_user, _indexes[i]);\n\n            if (matured) {\n                userTerms[_user][_indexes[i]].redeemed = time; // mark as redeemed\n                payout_ += pay;\n            }\n        }\n\n        req.transfer(_user, payout_);\n    }\n\n    /**\n     * @notice             redeem all redeemable markets for user\n     * @dev                if possible, query indexesFor() off-chain and input in redeem() to save gas\n     * @param _user        user to redeem all userTerms for\n     * @return             sum of payout sent, in REQ\n     */\n    function redeemAll(address _user) external override returns (uint256) {\n        return redeem(_user, indexesFor(_user));\n    }\n\n    /* ========== TRANSFER ========== */\n\n    /**\n     * @notice             approve an address to transfer a note\n     * @param _to          address to approve note transfer for\n     * @param _index       index of note to approve transfer for\n     */\n    function pushTerms(address _to, uint256 _index) external override {\n        require(userTerms[msg.sender][_index].created != 0, \"Depository: note not found\");\n        noteTransfers[msg.sender][_index] = _to;\n    }\n\n    /**\n     * @notice             transfer a note that has been approved by an address\n     * @param _from        the address that approved the note transfer\n     * @param _index       the index of the note to transfer (in the sender's array)\n     */\n    function pullTerms(address _from, uint256 _index) external override returns (uint256 newIndex_) {\n        require(noteTransfers[_from][_index] == msg.sender, \"Depository: transfer not found\");\n        require(userTerms[_from][_index].redeemed == 0, \"Depository: note redeemed\");\n\n        newIndex_ = userTerms[msg.sender].length;\n        userTerms[msg.sender].push(userTerms[_from][_index]);\n\n        delete userTerms[_from][_index];\n    }\n\n    /* ========== VIEW ========== */\n\n    // Terms info\n\n    /**\n     * @notice             all pending userTerms for user\n     * @param _user        the user to query userTerms for\n     * @return             the pending userTerms for the user\n     */\n    function indexesFor(address _user) public view override returns (uint256[] memory) {\n        UserTerms[] memory info = userTerms[_user];\n\n        uint256 length;\n        for (uint256 i = 0; i < info.length; i++) {\n            if (info[i].redeemed == 0 && info[i].payout != 0) length++;\n        }\n\n        uint256[] memory indexes = new uint256[](length);\n        uint256 position;\n\n        for (uint256 i = 0; i < info.length; i++) {\n            if (info[i].redeemed == 0 && info[i].payout != 0) {\n                indexes[position] = i;\n                position++;\n            }\n        }\n\n        return indexes;\n    }\n\n    /**\n     * @notice             calculate amount available for claim for a single note\n     * @param _user        the user that the note belongs to\n     * @param _index       the index of the note in the user's array\n     * @return payout_     the payout due, in gREQ\n     * @return matured_    if the payout can be redeemed\n     */\n    function pendingFor(address _user, uint256 _index) public view override returns (uint256 payout_, bool matured_) {\n        UserTerms memory note = userTerms[_user][_index];\n\n        payout_ = note.payout;\n        matured_ = note.redeemed == 0 && note.matured <= block.timestamp && note.payout != 0;\n    }\n}\n"
      },
      "contracts/libraries/SafeERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/ERC20/IERC20.sol\";\nimport \"./Address.sol\";\n\n// solhint-disable  max-line-length\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require((value == 0) || (token.allowance(address(this), spender) == 0), \"SafeERC20: approve from non-zero to non-zero allowance\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
      },
      "contracts/interfaces/ERC20/IERC20Metadata.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}"
      },
      "contracts/interfaces/IUserTermsKeeper.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.15;\n\ninterface IUserTermsKeeper {\n    // Info for market note\n    struct UserTerms {\n        uint256 payout; // REQ remaining to be paid\n        uint48 created; // time market was created\n        uint48 matured; // timestamp when market is matured\n        uint48 redeemed; // time market was redeemed\n        uint48 marketID; // market ID of deposit. uint48 to avoid adding a slot.\n    }\n\n    function redeem(\n        address _user,\n        uint256[] memory _indexes\n    ) external returns (uint256);\n\n    function redeemAll(address _user) external returns (uint256);\n \n    function pushTerms(address to, uint256 index) external;\n\n    function pullTerms(address from, uint256 index) external returns (uint256 newIndex_);\n\n    function indexesFor(address _user) external view returns (uint256[] memory);\n\n    function pendingFor(address _user, uint256 _index) external view returns (uint256 payout_, bool matured_);\n}\n"
      },
      "contracts/libraries/Address.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nlibrary Address {\n  function isContract(address account) internal view returns (bool) {\n    uint256 size;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      size := extcodesize(account)\n    }\n    return size > 0;\n  }\n\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n    (bool success, ) = recipient.call{value: amount}(\"\");\n    require(\n      success,\n      \"Address: unable to send value, recipient may have reverted\"\n    );\n  }\n\n  function functionCall(address target, bytes memory data)\n    internal\n    returns (bytes memory)\n  {\n    return functionCall(target, data, \"Address: low-level call failed\");\n  }\n\n  function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    return _functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n  ) internal returns (bytes memory) {\n    return\n      functionCallWithValue(\n        target,\n        data,\n        value,\n        \"Address: low-level call with value failed\"\n      );\n  }\n\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(\n      address(this).balance >= value,\n      \"Address: insufficient balance for call\"\n    );\n    require(isContract(target), \"Address: call to non-contract\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return _verifyCallResult(success, returndata, errorMessage);\n  }\n\n  function _functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 weiValue,\n    string memory errorMessage\n  ) private returns (bytes memory) {\n    require(isContract(target), \"Address: call to non-contract\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.call{value: weiValue}(\n      data\n    );\n    if (success) {\n      return returndata;\n    } else {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n\n  function functionStaticCall(address target, bytes memory data)\n    internal\n    view\n    returns (bytes memory)\n  {\n    return\n      functionStaticCall(target, data, \"Address: low-level static call failed\");\n  }\n\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    require(isContract(target), \"Address: static call to non-contract\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return _verifyCallResult(success, returndata, errorMessage);\n  }\n\n  function functionDelegateCall(address target, bytes memory data)\n    internal\n    returns (bytes memory)\n  {\n    return\n      functionDelegateCall(\n        target,\n        data,\n        \"Address: low-level delegate call failed\"\n      );\n  }\n\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(isContract(target), \"Address: delegate call to non-contract\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return _verifyCallResult(success, returndata, errorMessage);\n  }\n\n  function _verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) private pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      if (returndata.length > 0) {\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n\n  function toBytes32(address a) internal pure returns (bytes32 b) {\n    assembly {\n      let m := mload(0x40)\n      a := and(a, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n      mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, a))\n      mstore(0x40, add(m, 52))\n      b := m\n    }\n  }\n\n  function addressToString(address _address)\n    internal\n    pure\n    returns (string memory)\n  {\n    bytes32 _bytes = toBytes32(_address);\n    bytes memory HEX = \"0123456789abcdef\";\n    bytes memory _addr = new bytes(42);\n\n    _addr[0] = \"0\";\n    _addr[1] = \"x\";\n\n    for (uint256 i = 0; i < 20; i++) {\n      _addr[2 + i * 2] = HEX[uint8(_bytes[i + 12] >> 4)];\n      _addr[3 + i * 2] = HEX[uint8(_bytes[i + 12] & 0x0f)];\n    }\n\n    return string(_addr);\n  }\n}\n"
      },
      "contracts/interfaces/ITreasuryAuth.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.8.15;\n\nimport \"./IAuthority.sol\";\n\ninterface ITreasuryAuth is IAuthority {\n    function deposit(\n        uint256 _amount,\n        address _token,\n        uint256 _profit\n    ) external returns (uint256);\n\n    function withdraw(uint256 _amount, address _token) external;\n\n    function assetValue(address _token, uint256 _amount) external view returns (uint256 value_);\n\n    function mint(address _recipient, uint256 _amount) external;\n\n    function manage(address _token, uint256 _amount) external;\n\n    function incurDebt(uint256 amount_, address token_) external;\n\n    function repayDebtWithReserve(uint256 amount_, address token_) external;\n\n    function excessReserves() external view returns (int256);\n\n    function baseSupply() external view returns (uint256);\n}\n"
      }
    },
    "settings": {
      "optimizer": {
        "enabled": true,
        "runs": 999999
      },
      "evmVersion": "london",
      "outputSelection": {
        "*": {
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata",
            "devdoc",
            "userdoc",
            "storageLayout",
            "evm.gasEstimates"
          ],
          "": [
            "ast"
          ]
        }
      },
      "metadata": {
        "useLiteralContent": true
      },
      "libraries": {
        "": {
          "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
        }
      }
    }
  }